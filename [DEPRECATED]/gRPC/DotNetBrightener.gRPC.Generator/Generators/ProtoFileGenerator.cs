using DotNetBrightener.gRPC.Generator.SyntaxReceivers;
using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using DotNetBrightener.gRPC.Generator.Models;

namespace DotNetBrightener.gRPC.Generator.Generators;

[Generator]
public partial class ProtoFileGenerator : ISourceGenerator
{
    internal CodeGeneratorSchema CodeGeneratorInformation { get; private set; }

    internal List<ProtoFileModel> ProtoFiles { get; } = new();

    internal List<ServiceFileModel> ServiceFiles { get; } = new();

    internal List<MessageFileModel> MessageFiles { get; } = new();

    internal List<ServiceImplFileModel> ServiceImplFiles { get; } = new();

    protected virtual bool ShouldWriteFile => true;

    public virtual void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new AutoGenerateProtoFileReceiver());
    }

    /// <summary>
    /// And consume the receiver here.
    /// </summary>
    public void Execute(GeneratorExecutionContext context)
    {
        CodeGeneratorInformation = (context.SyntaxContextReceiver as AutoGenerateProtoFileReceiver)?.CodeGeneratorSchema;

        if (CodeGeneratorInformation is null ||
            CodeGeneratorInformation.ProtoFileDefinitions.Count == 0)
            return;

        var grpcAssemblyPath = CodeGeneratorInformation.GrpcAssemblyPath;

        var programCsFile = Path.Combine(grpcAssemblyPath, "Program.cs");

        string startupCsFileContent = string.Empty;

        if (File.Exists(programCsFile))
        {
            startupCsFileContent = InjectProtobufConfigsIfNeeded(programCsFile);
            AddAnnotationFilesIfNeeded(grpcAssemblyPath);
        }

        var neededUsings     = new List<string>();

        foreach (var protoFile in CodeGeneratorInformation.ProtoFileDefinitions)
        {
            var generatedProfoFile = GenerateProtoFile(Path.Combine(grpcAssemblyPath, "Protos"), protoFile);

            ProtoFiles.Add(generatedProfoFile);

            ServiceFiles.Add(GenerateGServiceFile(Path.Combine(grpcAssemblyPath, "Services"), protoFile));
            var serviceImplFile = GenerateServiceFile(Path.Combine(grpcAssemblyPath, "Services"), protoFile);

            ServiceImplFiles.Add(serviceImplFile);

            if (serviceImplFile is not null)
            {
                var protoServiceNamespace  = $"using {protoFile.ProtoServiceNamespace};";
                var targetServiceNamespace = $"using {protoFile.TargetAssemblyName}.Services;";

                if (!neededUsings.Contains(protoServiceNamespace))
                {
                    neededUsings.Add(protoServiceNamespace);
                }

                if (!neededUsings.Contains(targetServiceNamespace))
                {
                    neededUsings.Add(targetServiceNamespace);
                }
            }

            foreach (var message in protoFile.Messages)
            {
                var msgFile = GenerateMessageConvertorFile(Path.Combine(grpcAssemblyPath, "Converters"), message);

                if (msgFile is not null)
                {
                    MessageFiles.Add(msgFile);
                }
            }
        }


        foreach (var usingService in neededUsings.Distinct().OrderBy(self => self))
        {
            if (!startupCsFileContent.Contains(usingService))
            {
                startupCsFileContent = usingService + Environment.NewLine + startupCsFileContent;
            }
        }

        if (ShouldWriteFile)
        {
            var filesToWrite = new List<FileContentModel>();

            filesToWrite.AddRange(ProtoFiles);
            filesToWrite.AddRange(MessageFiles);
            filesToWrite.AddRange(ServiceFiles);
            filesToWrite.AddRange(ServiceImplFiles);

            foreach (var fileContentModel in filesToWrite)
            {
                var dirPath = Path.GetDirectoryName(fileContentModel.FilePath);

                if (!Directory.Exists(dirPath))
                {
                    Directory.CreateDirectory(dirPath);
                }

                switch (fileContentModel)
                {
                    // don't overwrite the service file if it already exists
                    case ServiceImplFileModel serviceFile when
                        File.Exists(serviceFile.FilePath):
                    case MessageFileModel messageFile when
                        File.Exists(messageFile.FilePath):
                        continue;
                }

                var fileContent = fileContentModel.FileContent;

                if (fileContentModel is ProtoFileModel)
                {
                    fileContent = $@"
// <auto-generated>
//     Generated by the protocol buffer generator.  DO NOT EDIT!
// </auto-generated>

{fileContent}
";
                }

                File.WriteAllText(fileContentModel.FilePath, fileContent);
            }

            var serviceFilesList = ServiceImplFiles.Select(x => x.ClassName)
                                                   .ToList();

            foreach (var serviceImplClassName in serviceFilesList.Distinct())
            {
                startupCsFileContent = InjectGrpcService(startupCsFileContent, serviceImplClassName);
            }

            File.WriteAllText(programCsFile, startupCsFileContent);

            var protoFilesList = ProtoFiles.Select(x => x.ClassName)
                                           .ToList();

            UpdateCsprojFile(grpcAssemblyPath, protoFilesList);
        }
    }
}