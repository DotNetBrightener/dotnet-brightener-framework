using Microsoft.CodeAnalysis;
using System.Collections.Immutable;
using System.Text;
using WebApi.GenericCRUD.Generator.SyntaxReceivers;
using WebApi.GenericCRUD.Generator.Utils;

namespace WebApi.GenericCRUD.Generator.Generators;

[Generator]
public class DataServiceClassGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register syntax provider instead of syntax receiver
        var syntaxProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: AutoGenerateDataServiceSyntaxReceiver.IsCandidateForGeneration,
                transform: (ctx, _) => AutoGenerateDataServiceSyntaxReceiver.GetSemanticTargetForGeneration(ctx))
            .Where(m => m != null);

        context.RegisterSourceOutput(syntaxProvider.Collect(), Execute);
    }

    private void Execute(SourceProductionContext context, ImmutableArray<IEnumerable<CodeGenerationInfo>> models)
    {
        var allModels = models.SelectMany(x => x.Where(m => m is not null).Select(m => m))
                              .ToArray();
        
        if (!allModels.Any())
            return;

        foreach (var modelClass in allModels)
        {
            GenerateDataServiceClass(context, modelClass);
        }
    }

    private static void GenerateDataServiceClass(SourceProductionContext context, CodeGenerationInfo modelClass)
    {
        var className = $"{modelClass.TargetEntity}DataService";
        var interfaceName = $"I{className}";

        var dataServiceInterfaceSrc = $@"
{FileTemplates.GetFileHeader(className)}

using System;
using System.ComponentModel.DataAnnotations;

using DotNetBrightener;
using DotNetBrightener.DataAccess.Services;
using {modelClass.TargetEntityNamespace};

namespace {modelClass.DataServiceNamespace};

public partial interface {interfaceName} : IBaseDataService<{modelClass.TargetEntity}>;";

        var dataServiceSrc = $@"
{FileTemplates.GetFileHeader(className)}

using System;
using System.ComponentModel.DataAnnotations;

using DotNetBrightener;
using DotNetBrightener.DataAccess.Services;
using {modelClass.TargetEntityNamespace};

namespace {modelClass.DataServiceNamespace};

public partial class {modelClass.TargetEntity}DataService : BaseDataService<{modelClass.TargetEntity}>, {interfaceName} {{

    private {modelClass.TargetEntity}DataService(IRepository repository)
        : base(repository)
    {{
    }}

}}";
        var targetFolder = modelClass.DataServicePath;

        if (!Directory.Exists(targetFolder))
        {
            Directory.CreateDirectory(targetFolder);
        }

        var protectedInterfacePath = GetProtectedGeneratedFilePath(targetFolder, $"{interfaceName}.g.cs");
        var protectedClassPath = GetProtectedGeneratedFilePath(targetFolder, $"{className}.g.cs");

        WriteProtectedGeneratedFile(protectedInterfacePath, dataServiceInterfaceSrc);
        WriteProtectedGeneratedFile(protectedClassPath, dataServiceSrc);

        context.AddSource($"{interfaceName}.g.cs", dataServiceInterfaceSrc);
        context.AddSource($"{className}.g.cs", dataServiceSrc);

        var defaultPathFile = Path.Combine(targetFolder, $"{className}.cs");

        if (!File.Exists(defaultPathFile))
        {
            var defaultServiceClassFileContent = $@"
using DotNetBrightener.DataAccess.Services;
using Microsoft.Extensions.Logging;

using {modelClass.TargetEntityNamespace};

namespace {modelClass.DataServiceNamespace};

public partial class {className}
{{
    private readonly ILogger _logger;

    public {className}(
            IRepository repository, 
            ILogger<{className}> logger)
        : this(repository)
    {{
        _logger = logger;
    }}

    // Implement your custom methods here
}}";
            File.WriteAllText(defaultPathFile, defaultServiceClassFileContent);
        }

        var defaultInterfacePathFile = Path.Combine(targetFolder, $"{interfaceName}.cs");

        if (!File.Exists(defaultInterfacePathFile))
        {
            var interfaceFileContent = $@"
using {modelClass.TargetEntityNamespace};

namespace {modelClass.DataServiceNamespace};

/// <summary>
///     Provides the data access methods for <see cref=""{modelClass.TargetEntity}"" /> entity.
/// </summary>
public partial interface {interfaceName}
{{
    // Provide your custom methods here
}}";
            File.WriteAllText(defaultInterfacePathFile, interfaceFileContent);
        }
    }

    /// <summary>
    /// Gets the protected path for generated files in the obj directory structure
    /// </summary>
    private static string GetProtectedGeneratedFilePath(string targetFolder, string fileName)
    {
        // Find the project root by looking for .csproj file
        var projectRoot = targetFolder.GetAssemblyPath();
        if (projectRoot == null)
        {
            // Fallback to target folder if project root not found
            return Path.Combine(targetFolder, "Generated", fileName);
        }

        // Use obj/Debug/netX.X/Generated as the protected location
        var objPath = Path.Combine(projectRoot, "obj");
        var generatedPath = Path.Combine(objPath, "Generated");

        return Path.Combine(generatedPath, fileName);
    }

    /// <summary>
    /// Writes a generated file to the protected location with proper headers and validation
    /// </summary>
    private static void WriteProtectedGeneratedFile(string filePath, string content)
    {
        try
        {
            // Ensure the directory exists
            var directory = Path.GetDirectoryName(filePath);
            if (!Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }

            // Write the file with UTF-8 encoding without BOM
            File.WriteAllText(filePath, content, new UTF8Encoding(false));

            // Set file attributes to indicate it's generated (read-only)
            File.SetAttributes(filePath, FileAttributes.ReadOnly);
        }
        catch (Exception ex)
        {
            // Log the error but don't fail the build - source context will still work
            Console.WriteLine($"Warning: Could not write protected generated file {filePath}: {ex.Message}");
        }
    }
}
